-- Create a table for public proles
create table profiles (
  id uuid references auth.users not null primary key,
  updated_at timestamp with time zone,
  username text unique,
  full_name text,
  avatar_url text,
  website text,
  timezone text,
  prompt_pack text,

  constraint username_length check (char_length(username) >= 3)
);

alter table profiles enable row level security;

create policy "Public profiles are viewable by everyone." on profiles
  for select using (true);

create policy "Users can insert their own profile." on profiles
  for insert with check (auth.uid() = id);

create policy "Users can update own profile." on profiles
  for update using (auth.uid() = id);

-- Set up Realtime!
begin;
  drop publication if exists supabase_realtime;
  create publication supabase_realtime;
commit;
alter publication supabase_realtime add table profiles;

-- Set up Storage!
insert into storage.buckets (id, name)
  values ('avatars', 'avatars');

create policy "Avatar images are publicly accessible." on storage.objects
  for select using (bucket_id = 'avatars');

create policy "Anyone can upload an avatar." on storage.objects
  for insert with check (bucket_id = 'avatars');

-- Journal Entries Table
create table entries (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  date date not null,
  raw_json jsonb,
  polished_html text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table entries enable row level security;

create policy "Users can view their own entries." on entries
  for select using (auth.uid() = user_id);

create policy "Users can insert their own entries." on entries
  for insert with check (auth.uid() = user_id);

create policy "Users can update their own entries." on entries
  for update using (auth.uid() = user_id);

create policy "Users can delete their own entries." on entries
  for delete using (auth.uid() = user_id);

alter publication supabase_realtime add table entries;

-- Photos Table
create table photos (
  id bigint generated by default as identity primary key,
  entry_id bigint references entries not null,
  storage_path text not null,
  caption text,
  created_at timestamp with time zone default timezone('utc'::text, now()) not null
);

alter table photos enable row level security;

-- This policy is a bit more complex. It checks that the user owns the entry the photo is associated with.
create policy "Users can view photos for their own entries." on photos
  for select using (auth.uid() = (select user_id from entries where id = photos.entry_id));

create policy "Users can insert photos for their own entries." on photos
  for insert with check (auth.uid() = (select user_id from entries where id = photos.entry_id));

create policy "Users can update photos for their own entries." on photos
  for update using (auth.uid() = (select user_id from entries where id = photos.entry_id));

create policy "Users can delete photos for their own entries." on photos
  for delete using (auth.uid() = (select user_id from entries where id = photos.entry_id));

alter publication supabase_realtime add table photos;

-- Function to create a profile for a new user
create function public.handle_new_user()
returns trigger as $$
begin
  insert into public.profiles (id, full_name, avatar_url)
  values (new.id, new.raw_user_meta_data->>'full_name', new.raw_user_meta_data->>'avatar_url');
  return new;
end;
$$ language plpgsql security definer;

-- Trigger to call the function when a new user signs up
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Create a bucket for entry photos
insert into storage.buckets (id, name, public)
  values ('entry_photos', 'entry_photos', false);

-- RLS policies for entry_photos bucket
create policy "Users can upload photos to their own folder." on storage.objects
  for insert with check (bucket_id = 'entry_photos' and auth.uid()::text = (storage.foldername(name))[1]);

create policy "Users can view their own photos." on storage.objects
  for select using (bucket_id = 'entry_photos' and auth.uid()::text = (storage.foldername(name))[1]);

create policy "Users can update their own photos." on storage.objects
  for update using (bucket_id = 'entry_photos' and auth.uid()::text = (storage.foldername(name))[1]);

create policy "Users can delete their own photos." on storage.objects
  for delete using (bucket_id = 'entry_photos' and auth.uid()::text = (storage.foldername(name))[1]);
